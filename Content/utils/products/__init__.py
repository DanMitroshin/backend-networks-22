import datetime
import re

from django.utils import timezone
from Content.models import (
    Product
)
from random import sample, shuffle, choices, randint

from Content.models import Product, TrainerBlock
from Statistics.models import TrainerBlockProgress, ProductProgress, ProductLog
from Content.constants import GENERATED_PRODUCT_TYPES, LESSON_TYPES


def get_difficult_blocks_by_balance(user, trainer_blocks, amount):
    """
    GET THE MOST PROBLEM TRAINER BLOCKS
    QUERYSET HAS BEEN ALREADY SORTED BY ORDERING IN MODEL BY BALANCE
    ;
    :param user: User object
    :param trainer_blocks: queryset of TrainerBlock objects
    :param amount: int, amount of difficult blocks
    :return: queryset of difficult_blocks ids
    """
    # print("INDEXES:", list(sorted(list(map(lambda x: x.id, trainer_blocks)))))
    difficult_trainer_blocks_ids = TrainerBlockProgress.objects.filter(
        user=user.id,
        trainer_block__in=trainer_blocks,
    ).prefetch_related('trainer_block')[:amount].values_list('trainer_block__id', flat=True)
    # print("INDEXES BLOCKS:", list(sorted(list(map(lambda x: x.trainer_block.id, difficult_trainer_blocks_ids)))))
    # progresses = TrainerBlockProgress.objects.filter(
    #     user=user.id,
    #     trainer_block__in=trainer_blocks,
    # ).prefetch_related('trainer_block')[:amount]
    # print("BALANCES:", list(map(lambda x: x.balance, progresses)))
    # print("IDS:", problem_trainer_blocks_ids)
    return difficult_trainer_blocks_ids


def get_active_trainer_blocks():
    return TrainerBlock.objects.exclude(active=0)


def sample_random_blocks(trainer_blocks, amount: int):
    """
    Sample randomly <amount> blocks of trainer_blocks queryset

    :param trainer_blocks: queryset of TrainerBlock objects
    :param amount: amount of objects for sampling
    :return: queryset of TrainerBlocks
    """
    # size = trainer_blocks.count()
    # if size - amount > 0:
    #     offset = randint(0, size - amount)
    # else:
    #     offset = 0
    #
    # if (size - offset) // amount >= 2:
    #     every_k = randint(1, (size - offset) // amount)
    # else:
    #     every_k = 1
    # offset = 0
    # every_k = 1
    # end_border = min(offset + every_k * amount, size - 1)
    # blocks = trainer_blocks.order_by('?')[offset:end_border:every_k]
    blocks = trainer_blocks.order_by('?')[:amount]
    return blocks


def generate_product(user, product_type=GENERATED_PRODUCT_TYPES.PERSONAL, tag='', amount=25, section=''):
    trainer_blocks = get_active_trainer_blocks()  # .order_by('?') - in random
    if tag != '':
        trainer_blocks = trainer_blocks.filter(tags=tag)
    if section != '':
        trainer_blocks = trainer_blocks.filter(section=section)
    product = Product.objects.create(
        name=f'{product_type} test {user.id}',
        lesson_type=LESSON_TYPES.P3_AUTOGENERATED_TRAINER_LESSON,
        theme=f'{product_type} tests',
        section=section)
    product.name += f'_{product.id}'

    if product_type == GENERATED_PRODUCT_TYPES.RANDOM:
        blocks = sample_random_blocks(trainer_blocks, amount)
        # print(f"Amount: {amount}, count: {size}, offset: {offset}, every_k: {every_k}, blocks amount: {len(blocks)}")
        # print(list(map(lambda x: x.id, blocks)))
        # return

        # counters = sample([i for i in range(size)], k=amount)
        # counters = sorted(counters)
        # # print("COUNTERS", counters)
        # # trainers = []
        # for i, block in enumerate(trainer_blocks):
        #     try:
        #         if i == counters[0]:
        #             blocks.append(block)
        #             counters.remove(counters[0])
        #     except:
        #         continue

    # elif product_type == GENERATED_PRODUCT_TYPES.PERSONAL:
    else:
        # start_time = time.time()

        difficult_blocks_amount = amount - amount // 4
        difficult_blocks = get_difficult_blocks_by_balance(
            user,
            trainer_blocks,
            difficult_blocks_amount,
        )
        difficult_blocks_count = difficult_blocks.count()
        # print("DIFFICULT COUNT:", difficult_blocks_count, difficult_blocks)
        # random_blocks_pool = trainer_blocks.difference(difficult_blocks)
        random_blocks_pool = trainer_blocks.exclude(id__in=difficult_blocks).values_list('id', flat=True)
        # print("RANDOM AMOUNT:", len(random_blocks_pool))
        random_blocks = sample(
            list(random_blocks_pool),
            k=amount - difficult_blocks_count
        )
        blocks = list(difficult_blocks) + random_blocks
        shuffle(blocks)
        # print("LEN BLOCKS HAVE:", len(set(blocks)))
        # print("BLOCKS:", blocks)
        # print("--- %s seconds ---" % (time.time() - start_time))
    # return None
    product.trainer_blocks.set(blocks)
    product.save()

    return product


def delete_old_personal_products():
    date = timezone.now().date() - timezone.timedelta(days=5)

    amount = len(Product.objects.filter(lesson_type='p3', creation_date__lt=date))
    Product.objects.filter(lesson_type='p3', creation_date__lt=date).delete()
    now_amount = len(Product.objects.filter(lesson_type='p3', creation_date__gt=date))

    return {'delete': amount, 'left': now_amount}


def clear_product_questions_from_tags(product):
    clean = re.compile('<.*?>')
    for r in product['questions']:
        r['question'] = re.sub(clean, '', r['question'])
    return product


def update_product_progress(product, user, completed):
    product_progress, _ = ProductProgress.objects.update_or_create(
        product=product,
        user=user
    )
    product_progress.completed = max(product_progress.completed, completed)
    product_progress.save()
    return product_progress


def update_coins_for_product(user, currently_completed):
    coins = 0
    if currently_completed >= 10:
        coins = 10
        user.coins += coins
        user.save()
    return coins
